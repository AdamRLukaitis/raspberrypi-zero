
This is a collection of baremetal examples specifically for the
raspberry pi zero.  Look at my other repositories for other raspberry
pi boards.

I have a raspberry pi repo at github (same place you found this repo)
that has been popular (relative to anything else I have put out there).
It started as soon as I got my first raspberry pi which was part of
the mad rush when they first came out for the general public.  For some
reason I assumed the design of both the board and chip would remain
somewhat static.  But that didnt happen.  First the boards then the
chips.  Granted the pi-zero changed once, but didnt affect anything
I was using.  And who knows simply writing this down may cause a
murphy's law thing and ruin this repo as well (they may change the
chip/board or get rid of it all together).  I do not dislike the other
chips or cards, but, the ARMv7 and ARMv8 cores independent of being
multicore, have added a plethera of security and priority features
that I struggle personally to absorb.  I have absorbed enough to get
through my normal mix of examples, but the ARMv6 has close ties to the
early ARM cores, and has enough features to allow Linux or other
operating systems to run, but does not have a myriad of different
possible ways of running it with a number of rules for each.  So with
the pi-zero I can both isolate the examples I have already written, and
perhaps refactor, and make some more.

As far as I am concerned baremetal means no operating system.  The
cloud computing community is trying to mis-use the word to mean fewer
operating systems, so I recommend you use the term "cloud baremetal"
for that incorrect use case.  Or use whatever term you want.  These
examples take the reference material with specific register addresses
in the ARM address space and talk to those register directly to make
things happen.  Or to create some simple libraries/functions that
are called by the main program, but there is no operating system to
take that direct access to the hardware away from you.  At the same
time I am taking control of the GNU compiler toolchain, mostly for
portability reasons (all different pre-builts and ways to build your
own that wouldnt have worked), but also as an educational tool for
the first baremetal stumbling block, just getting the thing to boot.

There is a very nice community of fellow baremetal developers at the
raspberry pi website in the forums under Programming -> baremetal.

https://www.raspberrypi.org

So click on forums at the top then under Programming the first forum
there is baremetal (alphabetically not because we are any more
important than others).

Lets dive in and then talk about what is going on.


---- building the sd card ----

Go to

https://github.com/raspberrypi

You DO NOT need to clone any of these repositories.

Click on the firmware repo
Then the boot directory

bootcode.bin file then click on View Raw to download (or right click
and save as depending on your browser).

then back up one level and download start.elf the same way.

Those are all the files we need from this repo, dont need kernel.img
or anything else.

You are going to need an sd card, doesnt need to be very big 1GB,
2GB, etc.  Can probalby only get 4GB, 8GB or larger these days, thos
are fine.

Format the sd card for FAT32, if not already, you wont need any
other files so you can clean up the root directory.

Copy bootcode.bin and start.elf to the root directory of the sdcard.
I have left a kernel.img file in the root directory of this repo
copy that file over as well, do not create a config.txt like you read
about on other sites, will cover that later.  Safely unmount your sd
card and place it in the pi-zero, plug a usb cable into the connector
nearest the corner.  The led nearest that corner should blink in a
heartbeat like manner, two blinks, pause, two blinks, pause...If this
doesnt work then you cant go any further, either you have done something
wrong or they have changed the firmware in a way that is now incompatible
with my example.  The heartbeat directory contains the source for this
kernel.img.

----

One of two things is going to happen from here on out.  For each example
or at least almost all of them.  You can copy the kernel.img file
from that example to the sd card, and put it back in the raspi and
power it on.  I call this the sd card dance.

1) power off raspi
2) remove sd card
3) insert sd card in reader
4) plug reader into computer
5) mount/wait
6) copy binary file to kernel.img
7) sync/wait
8) unmount
9) insert sd card in raspi
10) power raspi
11) repeat

And that is just part of the job if this is the programmable interface
you have been given then like myself and others you may have to repeat
this dance hundreds of times per application.

The first simplest alternative is to make or use a bootloader.  I have
one or a few and they are about as lean and mean and simple as it gets.
No features, I have no interest in hundreds of thousands of lines of
code in a bootloader, or a bootloader that pretty much is or needs
an operating system itself just to deal with all of its features.  My
bootloader will allow you to do the sd card dance one more time then
after that you can download your program over serial/uart into the
pi's memory and run it.  For each build you want to test you then
only need to:

1) power off raspi
2) power on raspi
3) download program
4) run program

Or if you add a reset button

1) reset raspi
2) download program
3) run program

There are two pins near the P1 header that say RUN next to them if you
short those pins together it will reset the PI.

Unfortunately for everyone the pi-zero did not come with the P1 headers
installed, so at some point you are going to want access to at least the
uart pins if not the whole header.  So either some soldering is required
or some push in friction based pins are needed.  Likewise a momentary
switch (normally open) to use as a reset button.

In order to use my bootloader you will need to gain access to those
uart pins, direct wired or header pins or some paperclips between boards
whatever.  This is actually not a compilicated thing you just need
the right tools (not expensive for ones that will work) and the
confidence to try.  I now have a collection of boards, almost all
FTDI based, but that is just due to their popularity, they are a
more expensive part than others.  Note RS-232 has no business in this
discussion, it is an electrical standard and will blow up your board,
you are looking for 3.3v serial or uart from usb on the host side.

Some examples

https://www.adafruit.com/product/954
https://www.sparkfun.com/products/9873
https://www.sparkfun.com/products/13263

At least one of which (I reserve the right to change this list at any
time) may also require soldering or cuts and jumpers to select the
desired voltage.  I bought a bunch from asia on ebay for like $2 each
or less with a 3.3v and 5v jumper you want 3.3v for the raspberry pi.

A uart solution, along with an led and resistor to blink are your
two most important tools in your baremetal programmers toolbox.  Plus
jumper wires or some way to hook these things up.  Soldering is
eventually required, but you can sometimes just get someone to do
that for you, or buy it that way.  Note that the general rule is the
tx and rx are in reference to that board/product so the raspberry pi
tx pin is an output, and rx an input, so you want to hook the tx of the
uart to the rx of the raspi and the tx of the raspi to the rx of the
usb uart board/cable.

I tend to use FTDI breakout boards with male pins on them that came
with or I added.  And female to female jumper wires I bought in a 100
pack from Sparkfun.  Adafruit carries these things as well.



You are going to need to go to the raspberrypi.org baremetal forum page
https://www.raspberrypi.org click on forums, under programming click on
baremetal.

or maybe this link works directly

https://www.raspberrypi.org/forums/viewforum.php?f=72

There is a sticky topic near the top called Bare Metal resources.
(is it bare metal with a space or baremetal without?  I have seen and
used both)

You definitely need the BCM2835-ARM-Peripherals document
And note the errata link there as well, there are lots of errors in the
document (which is true for any vendors documentation).

Either there or just google raspberry pi pinout to see the P1 header
pins.

The ones we care about initially are when you are holding the board
such that you are looking down on the top of the board (the side
the bulk of the components are on) and the dual row header is on the
right, the top right pin is pin1 the top left pin is pin 1 and they
alternate like that.  The right edge of the board is thus 2,4,6,8
and so on.

2  outer corner
4
6  ground
8  TX out
10 RX in

Wire these up to your usb uart solution tx to rx, rx to tx.  Figure
out a dumb terminal program like minicom on linux or teraterm on windows
or a myriad of others (putty works).  And then you can install my
bootloader on your sd card, and have a lot of fun without needing to
remove the sd card again.  When ready to deploy your application then
copy your binary file to the board with the filename kernel.img and
power on.  Note that I am initializing some peripherals so if you rely
on those and didnt initialize them yourself then you have more work
to do.

WIP (Work In Progress)...










